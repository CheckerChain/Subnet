"""
CommuneX Validator implementation for CheckerChain

This module provides CheckerChainValidator class for validating trust_score generated by modules in subnets.
The CheckerChainValidator retrieves module addresses from the subnet, prompts the modules to generate trust_score to a given product,
and scores the generated scores against the actual score when available.

Classes:
    CheckerChainValidator: A class for validating trust_score generated by modules in a subnet.
"""

import asyncio
import concurrent.futures
import time
from functools import partial
from typing import List

from communex.client import CommuneClient
from communex.module.client import ModuleClient
from communex.module.module import Module 
from communex.types import Ss58Address
from substrateinterface import Keypair  # type: ignore

from .util import set_weights, get_ip_port, get_ip_port
from ._config import ValidatorSettings
from ..utils import log
from .database.db_utils import add_prediction, create_db, get_predictions_for_product
from .database.utils import fetch_products


class CheckerChainValidator(Module):
    """
    A class for validating trust_score generated by modules in a subnet.

    Attributes:
        client: The CommuneClient instance used to interact with the subnet.
        key: The keypair used for authentication.
        netuid: The unique identifier of the subnet.
        val_model: The validation model used for scoring answers.
        call_timeout: The timeout value for module calls in seconds (default: 60).

    Methods:
        get_modules: Retrieve all module addresses from the subnet.
        _get_miner_prediction: Prompt a miner module to generate an answer to the given question.
        _score_miner: Score the generated answer against the validator's own answer.
        validate_step: Perform a validation step by generating questions, prompting modules, and scoring answers.
        validation_loop: Run the validation loop continuously based on the provided settings.
    """

    def __init__(
        self,
        key: Keypair,
        netuid: int,
        client: CommuneClient,
        call_timeout: int = 60,
    ) -> None:
        super().__init__()
        self.client = client
        self.key = key
        self.netuid = netuid
        self.val_model = "foo"
        self.call_timeout = call_timeout

    def get_addresses(self, client: CommuneClient, netuid: int) -> dict[int, str]:
        """
        Retrieve all module addresses from the subnet.

        Args:
            client: The CommuneClient instance used to query the subnet.
            netuid: The unique identifier of the subnet.

        Returns:
            A dictionary mapping module IDs to their addresses.
        """

        # Makes a blockchain query for the miner addresses
        module_addresses = client.query_map_address(netuid)
        return module_addresses

    def _get_miner_prediction(
        self,
        question: List[str],
        miner_info: tuple[list[str], Ss58Address],
    ) -> List[str | None]:
        """
        Prompt a miner module to generate an answer to the given question.

        Args:
            question: The question to ask the miner module.
            miner_info: A tuple containing the miner's connection information and key.

        Returns:
            The generated answer from the miner module, or None if the miner fails to generate an answer.
        """
        connection, miner_key = miner_info
        module_ip, module_port = connection
        client = ModuleClient(module_ip, int(module_port), self.key)
        try:
            # handles the communication with the miner
            miner_answer = asyncio.run(
                client.call(
                    "generate",
                    miner_key,
                    {"prompt": question},
                    timeout=self.call_timeout,  # Â type: ignore
                )
            )
            miner_answer = miner_answer["answer"]

        except Exception as e:
            log(f"Miner {module_ip}:{module_port} failed to generate an answer")
            print(e)
            miner_answer = None
        return miner_answer

    def _score_miner(self, miner_answer: float, actual_answer: float) -> float:
        """
        Score the generated answer against the checker-chain's answer.

        Args:
            miner_answer: The generated trust score from the miner module.
            actual_answer: The trust score from checker chain.

        Returns:
            The score assigned to the miner's answer.
        """
        score = 100 - abs(miner_answer - actual_answer)
        return score / 100; # since max score is 1

    def get_and_store_predictions(self,syntia_netuid:int, unmined_products: List[str]):
        modules_addresses = self.get_addresses(self.client, syntia_netuid)
        modules_keys = self.client.query_map_key(syntia_netuid)
        
        modules_info: dict[int, tuple[list[str], Ss58Address]] = {}

        modules_filtered_address = get_ip_port(modules_addresses)
        for module_id in modules_keys.keys():
            module_addr = modules_filtered_address.get(module_id, None)
            if not module_addr:
                continue
            modules_info[module_id] = (module_addr, modules_keys[module_id])

        miner_prompt = unmined_products
        get_miner_prediction = partial(self._get_miner_prediction, miner_prompt)

        log(f"Selected the following miners: {modules_info.keys()}")

        with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
            it = executor.map(get_miner_prediction, modules_info.values())
            miner_answers = [*it]

        for uid, miner_response in zip(modules_info.keys(), miner_answers):
            miner_answer = miner_response
            if not miner_answer:
                log(f"Skipping miner {uid} that didn't answer")
                continue
            for product_id, prediction in zip(miner_prompt, miner_answer):
                add_prediction(product_id, uid, prediction)



    async def validate_step(
        self, syntia_netuid: int, settings: ValidatorSettings
    ) -> None:
        """
        Perform a validation step.

        Generates questions based on the provided settings, prompts modules to generate answers,
        and scores the generated answers against the validator's own answers.

        Args:
            syntia_netuid: The network UID of the subnet.
        """

        modules_keys = self.client.query_map_key(syntia_netuid)
        val_ss58 = self.key.ss58_address
        if val_ss58 not in modules_keys.values():
            raise RuntimeError(f"validator key {val_ss58} is not registered in subnet")

        score_dict: dict[int, float] = {}

        data = fetch_products()

        if not data.unmined_products:
            log("No new products to review.")

        if(data.unmined_products):
            self.get_and_store_predictions(syntia_netuid, data.unmined_products)

        if not data.reward_items:
            log("No products which have been reviewed and need to be scored")
            return None

        reward_product = data.reward_items[0]
        product_predictions = get_predictions_for_product(
            reward_product._id) or []
        predictions = [p["prediction"] for p in product_predictions]
        miner_ids = [p["miner_id"] for p in product_predictions]

        for uid, miner_response in zip(miner_ids, predictions):
            score = self._score_miner(float(miner_response), reward_product.trustScore)
            time.sleep(0.5)
            # score has to be lower or eq to 1, as one is the best score, you can implement your custom logic
            assert score <= 1
            score_dict[uid] = score

        if not score_dict:
            log("No miner managed to give a valid answer")
            return None

        # the blockchain call to set the weights
        _ = set_weights(settings, score_dict, self.netuid, self.client, self.key)

    def validation_loop(self, settings: ValidatorSettings) -> None:
        """
        Run the validation loop continuously based on the provided settings.

        Args:
            settings: The validator settings to use for the validation loop.
        """
        create_db()
        while True:
            start_time = time.time()
            _ = asyncio.run(self.validate_step(self.netuid, settings))

            elapsed = time.time() - start_time
            if elapsed < settings.iteration_interval:
                sleep_time = settings.iteration_interval - elapsed
                log(f"Sleeping for {sleep_time}")
                time.sleep(sleep_time)
